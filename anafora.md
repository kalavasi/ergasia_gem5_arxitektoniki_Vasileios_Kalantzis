# ergasia_gem5_arxitektoniki_Vasileios_Kalantzis
Το repository με την εργασία gem5 για το μάθημα αρχιτεκτονικής υπολογιστών

# Αναφορά Project: Gem5 Simulation

## Πρώτο Μέρος

### 1.
Σύμφωνα με το strarter_se.py τα βασικά χαρακτηριστικά του συστήματος είναι MinorCPU (αυτό το επιλέξαμε εμείς) ως τύπος CPU, η συχνότητα λειτουργίας είναι 1GHz, έχουμε έναν πυρήνα, L1 cache, walker cache και L2 cache που έχουν 64 cache_line_size, 2 μνήμες DDR3_1600_8x8 με μέγεθος 2GB.

### 2.
**Α.** Αυτά τα καταλαβαίνουμε από το starter_se.py. Για να επιβεβαιώσουμε τα χαρακτηριστικά του συστήματος και να δούμε επιλογές που μπορεί να μην φαίνονται χρησιμοποιούμε το config.ini και βλέπουμε τιμές για dcache, icache, L2 cache και walker cache.

![dcache_info](images/dcache_info.png)
![icache_info](images/icahe_info.png)
![l2_info](images/l2_info.png)
![walker_info](images/walker_png.png)

Όπου το assoc είναι το associativity, το entry_size είναι το cache_line και το size αντιστοιχεί στο μέγεθος.

**DDR3**
[system.mem_ctrls0]
tCK=1250
device_size=536870912
devices_per_rank=8
ranks_per_channel=2

Άρα η κάθε RAM είναι 512*8*2=8GB, αλλά έχουμε 2 DDR ίδιου μεγέθους → συνολικά 16GB.

**Β.** Sim_seconds: χρόνος που τρέχει το πρόγραμμα στο hardware που εξομοιώνουμε (arm επεξεργαστής με minorCPU). Sim_ticks: η μονάδα χρονικής μέτρησης στο Gem5, 1 tick = 1 / clk_frequency. Sim_insts: αριθμός εντολών που εκτελούνται μόνο στο προσομοιωμένο σύστημα. Host_inst_rate: ρυθμός εκτέλεσης εντολών στον υπολογιστή που τρέχει την προσομοίωση (εντολή/s).

**Γ.** Κοιτώντας τα committed instructions και τα instructions δεν είδα διαφορά στα νούμερα. Λογικά αν υπήρχε διαφορά θα ήταν εξαιτίας πραγμάτων όπως out of order execution και branch misprediction. Το νούμερο αλλάζει ανάλογα με το μοντέλο του επεξεργαστή που θα χρησιμοποιήσουμε.

**Δ.** Οι τιμές των προσπελάσεων dcache και l2 είναι:
system.cpu_cluster.cpus.dcache.overall_accesses::total 2160
system.cpu_cluster.l2.overall_accesses::total 474

### 3.
Timing Simple CPU: είναι ένα απλό μοντέλο CPU που χρησιμοποιείται κυρίως για testing. Κάθε αριθμητική εντολή τελειώνει σε έναν κύκλο ενώ οι προσπελάσεις μνήμης απαιτούν πολλούς κύκλους.

MinorCPU: Είναι ένας πιο περίπλοκος επεξεργαστής με 4 pipeline stages. Το πρώτο fetch παίρνει τις πληροφορίες από τη μνήμη. Το δεύτερο βάζει τις εντολές σε ένα buffer και τις χωρίζει σε ξεχωριστές εντολές, οι οποίες μπαίνουν σε ένα διάνυσμα και πηγαίνουν στο επόμενο στάδιο. Στο διάνυσμα προστίθεται το αποτέλεσμα του branch predictor ενώ ενημερώνεται το πρώτο fetch. Στο στάδιο decoding το διάνυσμα επεξεργάζεται για εκτέλεση στο επόμενο στάδιο. Στο execute εκτελούνται οι εντολές. Μέσω του gem5 μπορούμε να αλλάξουμε παραμέτρους για τα διανύσματα.

Το πρόγραμμα και τα αποτελέσματα:
[πρόγραμμα](files/number_folder)
[Αποτελέσματα minorCPU](files/number_result/Minor_CPU_number)
[Αποτελέσματα TimingSimpleCPU](files/number_result/Timing_Simple_CPU_number)

Κοιτώντας τα αποτελέσματα για τους 2 επεξεργαστές παρατηρούμε διαφορές. Ο χρόνος host_seconds είναι τριπλάσιος στην minorCPU ενώ το sim_seconds μικρότερο, δείχνοντας ότι η minorCPU είναι πιο περίπλοκη αλλά το simulated πρόγραμμα τρέχει πιο γρήγορα λόγω pipeline. Αλλαγή σε system clock και CPU clock σε 2GHz: μειώθηκαν οι χρόνοι εκτέλεσης και των 2 επεξεργαστών. Μειώθηκε το CPI στην minorCPU και οι κύκλοι προσομοίωσης στην TimingSimpleCPU. Αλλαγή σε DDR4_2400_16x4: μικρή βελτίωση στην minorCPU. Το bandwidth αυξήθηκε, το latency της μνήμης μειώθηκε, αλλά το πρόγραμμα είναι απλό οπότε η διαφορά μικρή. Ομοίως στην TimingSimpleCPU.

## Μέρος 2

[Το excel με τις τιμές για το μέρος 2. Υπάρχει 1 φύλλο για κάθε βήμα](files/arch_ergasia.xlsx)
[Επιπλέον το bash script γραμμένο με βοήθεια AI](files/run_spec.sh)

### Βήμα 1
1. Η default τιμές είναι:  
Icache: associativity=2, Size=32KB  
Dcache: associativity=2, Size=64KB  
L2: associativity=8, Size=2ΜΒ  
To cache_line είναι 64  
Η κύρια μνήμη είναι DDR3_1600_8x8 με χωρητικότητα 512MBx8x2=8GB

2. [Οι τιμές του gem5](files/spec_results.zip)

Με βάση τις πληροφορίες από το stats.txt βλέπουμε τις αποδόσεις του συστήματος για διάφορα benchmarks. Βλέποντας το CPI καταλαβαίνουμε την απόδοση. Εφόσον το ιδανικό CPI είναι 1, παρατηρούμε χώρο για βελτίωση ειδικά στα benchmarks speclibm και specsjeng. Το miss rate του L2 φτάνει κοντά στο 100%.

3. Αλλαγή GHz CPU

Αρχικά το system clock είναι 1GHz, CPU 2GHz. Αλλάζοντας τα GHz του επεξεργαστή επιταχύνουμε μόνο τη λειτουργία του pipeline. Το system δεν αλλάζει συχνότητα, υπάρχουν άλλες συσκευές με δικά τους clocks. Δεν υπάρχει τέλειο scaling λόγω cache miss και DRAM latency. Το φαινόμενο πιο έντονο σε benchmarks που χρησιμοποιούν πολύ μνήμη.

4. Αλλαγή μόνο DDR3_1600_x64 σε DDR3_2133_x64

Εφόσον βάλαμε πιο γρήγορη DRAM τα benchmarks που απαιτούν πολλές προσβάσεις στη μνήμη έχουν μειωμένο CPI και τρέχουν πιο γρήγορα.

## Βήμα 2ο

1. Το κύριο πρόβλημα με τις μνήμες cache είναι τα miss rate τους (ειδικά η L2). Με τα επόμενα 10 πειράματα προσπαθώ να αλλάξω τις μνήμες ώστε να μειώσω το miss rate. Οι συνδυασμοί που απορρίπτω είναι μικρότερα μεγέθη από ότι έχω τώρα και μικρότερο associativity. Επίσης το μικρότερο cacheline. Οι παραπάνω συνδυασμοί χειροτερεύουν το miss rate.

Σημείωση: σε κάποια test έχω βάλει μικρότερη L2 από την αρχική.

2. Τα τεστ είναι:
[Επιπλέον το bash script για τα τεστ](files/run_spec_cache.sh)
[Τα αποτελέσματα των τεστ στο gem5](files/spec_results_caches.zip)

Γενικά παρατηρούμε ότι κάθε benchmark έχει τις ιδιαιτερότητες του. Το μέγεθος του cacheline φαίνεται να είναι ο πιο καθοριστικός παράγοντας στην μείωση του CPI. Ακολουθεί η αύξηση του associativity και μετά οι αλλαγές στα μεγέθη. Ιδιαίτερο ενδιαφέρον προκαλεί το test 7 στον specmcf.

## Βήμα 3ο – Συνάρτηση Κόστους

Από τις βασικές αρχές της σχεδίασης ψηφιακών κυκλωμάτων γνωρίζουμε ότι το κόστος υλοποίησης μιας μνήμης αυξάνεται με το μέγεθός της. Παράλληλα, όσο αυξάνεται το μέγεθος της μνήμης αυξάνεται και το latency πρόσβασης, γεγονός που αποτελεί έναν από τους βασικούς λόγους ύπαρξης της ιεραρχίας μνημών και των cache. Στο Βήμα 2 μεταβλήθηκαν το μέγεθος των cache, το associativity και το cache line size, παράγοντες που επηρεάζουν τόσο την πολυπλοκότητα όσο και την ταχύτητα του συστήματος.

Το μέγεθος της cache επηρεάζει γραμμικά το κόστος υλοποίησης. Το associativity επηρεάζει το κόστος, αφού η αύξησή του συνεπάγεται περισσότερους συγκριτές και πιο σύνθετη λογική. Το cache line size επηρεάζει το miss penalty, αυξάνοντας τον χρόνο πρόσβασης. Επιπλέον η L1 cache θεωρείται ακριβότερη σε σχέση με την L2.

Μια ενδεικτική συνάρτηση κόστους:




Η πρώτη παρένθεση με τον όρο w1 είναι το κόστος μεγέθους, η δεύτερη ο χρόνος που χρειάζεται για hit και η τρίτη η καθυστέρηση της μνήμης για miss. L1 > L2, S_L1 S_L2 το μέγεθος των cache, A_L1 A_L2 το associativity, CL_L1 CL_L2 το cache line size.

Με βάση τα αποτελέσματα του Βήματος 2, η αρχιτεκτονική με το μικρότερο CPI δεν είναι πάντα βέλτιστη όταν συνυπολογιστεί το κόστος. Για τα περισσότερα benchmarks, όπως specbzip και specmcf, η μετάβαση από test_9 σε test_10 προσφέρει μικρή βελτίωση στο CPI, αλλά αυξάνει το κόστος. Το test_9 προσφέρει καλύτερη ισορροπία μεταξύ απόδοσης και κόστους.

Σε benchmarks με έντονη χρήση μνήμης όπως speclibm και specsjeng, η μείωση του CPI δικαιολογεί το αυξημένο κόστος του test_10. Η βέλτιστη αρχιτεκτονική εξαρτάται από το workload: για γενική χρήση προτείνεται test_9, ενώ για εφαρμογές με έντονη χρήση μνήμης το test_10.

## Βιβλιογραφία
Arm Research Starter Kit: System Modeling using gem5, Ashkan Tousi and Chuan Zhu, July 2017 [1](files/gem5_rsk.pdf)

David A. Patterson, John L. Hennessy, Αρχιτεκτονική Υπολογιστών – 6η αμερικανική έκδοση [2]
